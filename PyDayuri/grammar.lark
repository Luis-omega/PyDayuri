%import common.WS_INLINE
%declare _INDENT _DEDENT
%ignore WS_INLINE
_NL: /(\r?\n[\t ]*)+/



//_IDENTIFIER_HEAD : /(?!(\d|_))\w/u
//_IDENTIFIER_BODY :  /\w/u
IDENTIFIER : /(?!(\d|_))\w\w*/u


UINT : /[1-9][0-9_]*/

NUMERIC_HOLE.2 : /_[1-9][0-9]*/
NAMED_HOLE.2 : /_(?!(\d|_))\w\w*/
HOLE : /_/

path : IDENTIFIER ("." IDENTIFIER)*

import : "import" path "as" IDENTIFIER
  | "import" path 

pattern_hole :  NUMERIC_HOLE
  | NAMED_HOLE
  | HOLE


pattern_list : "[" pattern_match ("," pattern_match)+ "]"
  | "[" pattern_match "]" -> patter_list_singleton
  | "[" "]" -> pattern_list_empty


pattern_paren : "(" ")" -> pattern_empty
  | "(" pattern_match ")" -> pattern_group
  | "(" pattern_match ("," pattern_match)+ ")"  -> pattern_tuple

_pattern_not_application : pattern_hole
  | pattern_list
  | pattern_paren

pattern_application_recursive : pattern_application_recursive path
  | pattern_application_recursive _pattern_not_application
  | path
  | _pattern_not_application


// application has bigger precedence to be able to capture all the fields of the application
// otherwise : f a b c would be parsed as (f (a (b c))) 
// of course this means that we have to transform ((f a) b) c) to (f,[a b c]) if we want lists
pattern_path : path pattern_application_recursive -> pattern_application
  | path
  | path "@" pattern_match -> pattern_bind

pattern_match : pattern_path



exp_paren :  "(" ")" -> exp_empty
  | "(" _exp ("," _exp )+ ")" -> exp_tuple
  | "(" _exp ")"  -> exp_group


exp_bracket : "[" "]" -> exp_list_empty
  | "[" _exp ("," _exp) "]" -> exp_list
  | "[" _exp "]" -> exp_list_singleton

exp_let_eq : pattern_match "=" _exp

_indent_block{p} : _NL _INDENT p _NL? _DEDENT 

exp_let : "let" exp_let_eq  "in" _exp
  | "let" exp_let_eq "in" _NL _INDENT _exp _NL _DEDENT
  | "let" _NL  _INDENT ( exp_let_eq _NL)* exp_let_eq _NL _DEDENT  "in" _exp
  | "let" _NL  _INDENT ( exp_let_eq _NL)* exp_let_eq _NL _DEDENT  "in" _NL _INDENT _exp _NL _DEDENT

exp_match_case : pattern_match "->" _exp

exp_match : "match" _exp "of" _NL _INDENT exp_match_case (_NL exp_match_case)* _NL _DEDENT


exp_application : path _exp
  | exp_paren _exp

_exp_atom : UINT
  | exp_paren
  | exp_bracket
  | exp_let
  | exp_match
  | exp_application


exp_annotated : "a" _exp_atom ":" "b"

exp_free : _exp_atom

_exp : exp_free
  | exp_annotated




start : _exp _NL?


