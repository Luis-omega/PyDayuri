%import common.WS_INLINE
%declare _INDENT _DEDENT
%ignore WS_INLINE
_NL: /(\r?\n[\t ]*)+/



//_IDENTIFIER_HEAD : /(?!(\d|_))\w/u
//_IDENTIFIER_BODY :  /\w/u
IDENTIFIER : /(?!(\d|_))\w\w*/u


UINT : /[1-9][0-9_]*/

NUMERIC_HOLE : /_[1-9][0-9]*/
NAMED_HOLE : /_(?!(\d|_))\w\w*/

path : IDENTIFIER ("." IDENTIFIER)*

import : "import" path "as" IDENTIFIER
  | "import" path 

pattern_hole :  NUMERIC_HOLE
  | NAMED_HOLE


// We are avoiding to use "*" and "+" in all the grammar
// problem is that too much use leads to hidden shift//reduce  conflicts
// we want a unambiguous grammar. 
// I'll put "+" and "*" in the right places once we are more advanced
// (or i won't since this way allow us to craft ourselves a parser later with ease)
pattern_list_recursive : pattern_list_recursive ","  pattern_match 
  | "," pattern_match 

pattern_list : "[" pattern_match pattern_list_recursive "]"
  | "[" pattern_match "]" -> patter_list_singleton
  | "[" "]" -> pattern_list_empty

pattern_tuple_recursive : pattern_tuple_recursive "," pattern_match 
  | "," pattern_match

pattern_paren : "(" ")" -> pattern_empty
  | "(" pattern_match ")" -> pattern_group
  | "(" pattern_match pattern_tuple_recursive ")"  -> pattern_tuple

_pattern_not_application : pattern_hole
  | pattern_list
  | pattern_paren

pattern_application_recursive : pattern_application_recursive path
  | pattern_application_recursive _pattern_not_application
  | path
  | _pattern_not_application


// application has bigger precedence to be able to capture all the fields of the application
// otherwise : f a b c would be parsed as (f (a (b c))) 
// of course this means that we have to transform ((f a) b) c) to (f,[a b c]) if we want lists
pattern_maybe_application : path pattern_application_recursive -> pattern_application
  | path -> pattern_single_path

pattern_match : pattern_maybe_application




start : pattern_match


